# -*- coding: utf-8 -*-
"""Bubble Exam Sheet OMR.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1lVoJPJzklcZfFpj8J8U7OD2Cs0E6CUsL
"""

import cv2
import matplotlib.pyplot as plt

def show_im(img):
  plt.imshow(img)
  plt.show()

!pip install imutils
import imutils

img = cv2.imread("sheet.png")
color_img = cv2.cvtColor(img,cv2.COLOR_BGR2RGB)
show_im(color_img)
img = cv2.cvtColor(img,cv2.COLOR_BGR2GRAY)
show_im(img)

blur_img = cv2.GaussianBlur(img,(5,5),0)
edge = cv2.Canny(blur_img,100,200)
show_im(edge)

contours = cv2.findContours(edge,cv2.RETR_EXTERNAL,cv2.CHAIN_APPROX_SIMPLE)
contours = imutils.grab_contours(contours)
output = img.copy()
print(len(contours))
for cnt in contours:
  cv2.drawContours(output, [cnt], -1, (0, 0, 200), 3)
  show_im(output)

paperContour = None
for cnt in contours:
  perimeter = cv2.arcLength(cnt,True) # calculate permeter of contours & True means contours is closed 
  approx = cv2.approxPolyDP(cnt, 0.02 * perimeter, True) # True means closed area

  print(len(approx))

  if(len(approx) == 4):
    paperContour = approx
    break
print(paperContour)

from imutils.perspective import four_point_transform

sheet = four_point_transform(color_img,paperContour.reshape((4,2)))
gray_sheet = four_point_transform(img,paperContour.reshape((4,2)))
show_im(sheet)
show_im(gray_sheet)

# apply Otsu's thresholding method to binarize the warped
# piece of paper
thresh = cv2.threshold(gray_sheet, 0, 255,cv2.THRESH_BINARY_INV | cv2.THRESH_OTSU)[1]
show_im(thresh)

cnts = cv2.findContours(thresh.copy(), cv2.RETR_EXTERNAL,cv2.CHAIN_APPROX_SIMPLE)
cnts = imutils.grab_contours(cnts)
print(len(cnts))

# cnts contains not only bubble but also unnecessary contours
# We need to exclude these contours
bubbleConts = []
temp = gray_sheet.copy()
for c in cnts:
	# compute the bounding box of the contour, then use the
	# bounding box to derive the aspect ratio
	(x, y, w, h) = cv2.boundingRect(c)
	ar = w / float(h)
	# in order to label the contour as a question, region
	# should be sufficiently wide, sufficiently tall, and
	# have an aspect ratio approximately equal to 1
	if w >= 20 and h >= 20 and ar >= 0.9 and ar <= 1.1:
		bubbleConts.append(c)

for bCnt in bubbleConts:
  cv2.drawContours(temp,[bCnt],-1,(225,0,0),3)
show_im(temp)

ANSWER_KEY = {0: 1, 1: 4, 2: 0, 3: 3, 4: 1}

import numpy as np
from imutils import contours
bubbleConts = contours.sort_contours(bubbleConts,method="top-to-bottom")[0] # method returns (cnts,boundingBox)

correct = 0

# make five cnts per row
show_im(thresh)
final_output = sheet.copy()
for (bubble,index) in enumerate(np.arange(0,len(bubbleConts),5)):
  inner_cnts = contours.sort_contours(bubbleConts[index:index + 5])[0]
  bubbled = None
  for (index2,cnt) in enumerate(inner_cnts):
    zero_mask = np.zeros(thresh.shape, dtype="uint8")
    cv2.drawContours(zero_mask, [cnt], -1, 255, -1)
    non_zero_mask = cv2.bitwise_and(thresh, thresh, mask=zero_mask)
    total = cv2.countNonZero(non_zero_mask)
    if bubbled is None or total > bubbled[0]:
      bubbled = (total, index2)
      color = (255, 0, 0)
      key = ANSWER_KEY[bubble]
      if key == bubbled[1]:
        color = (0, 255, 0)
      cv2.drawContours(final_output, [inner_cnts[key]], -1, color, 3)

score = (correct / 5.0) * 100
cv2.putText(final_output,f"Score is {score}",(10, 30),cv2.FONT_HERSHEY_SIMPLEX, 0.9, (0, 0, 255), 2)
show_im(sheet)